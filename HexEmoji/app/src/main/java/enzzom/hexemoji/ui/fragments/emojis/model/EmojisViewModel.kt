package enzzom.hexemoji.ui.fragments.emojis.model

import android.os.CountDownTimer
import androidx.lifecycle.LiveData
import androidx.lifecycle.MediatorLiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import enzzom.hexemoji.data.entities.Challenge
import enzzom.hexemoji.data.entities.Emoji
import enzzom.hexemoji.data.entities.GeneralChallenge
import enzzom.hexemoji.data.repositories.ChallengesRepository
import enzzom.hexemoji.data.repositories.EmojiRepository
import enzzom.hexemoji.models.BoardSize
import enzzom.hexemoji.models.EmojiCategory
import enzzom.hexemoji.models.GameMode
import kotlinx.coroutines.launch
import javax.inject.Inject
import kotlin.math.min
import kotlin.random.Random

private const val MIN_LOADING_TIME_MS = 600L

private const val MAX_CHALLENGES_PER_CATEGORY = 5
private const val MAX_GAMES_PER_CHALLENGE = 6

/**
 * TODO
 */
@HiltViewModel
class EmojisViewModel @Inject constructor(
    private val emojiRepository: EmojiRepository,
    private val challengesRepository: ChallengesRepository
) : ViewModel() {

    private val _categoriesLoadingFinished = MutableLiveData(false)
    private val _minLoadingTimeFinished = MutableLiveData(false)

    private val _collectionsLoadingFinished = MediatorLiveData(false).also {
        it.addSource(_categoriesLoadingFinished) { finished -> it.value = finished && _minLoadingTimeFinished.value!! }
        it.addSource(_minLoadingTimeFinished) { finished -> it.value = finished && _categoriesLoadingFinished.value!! }
    }
    val collectionsLoadingFinished: LiveData<Boolean> = _collectionsLoadingFinished

    private var allEmojisByCategory: Map<EmojiCategory, List<Emoji>>? = null
    private var allChallengesByCategory: MutableMap<EmojiCategory, List<Challenge>>? = null

    private var categoriesUnlockedCount: Map<EmojiCategory, Int>? = null
    private var categoriesEmojiCount: Map<EmojiCategory, Int>? = null

    init {
        initMinimumLoadingTime()

        viewModelScope.launch {
            allChallengesByCategory = challengesRepository.getAllChallengesByCategory().toMutableMap()

            allEmojisByCategory = emojiRepository.getAllEmojisByCategory()

            categoriesEmojiCount = allEmojisByCategory!!.mapValues { it.value.size }
            categoriesUnlockedCount = allEmojisByCategory!!.mapValues { it.value.count { emoji -> emoji.unlocked }  }

            _categoriesLoadingFinished.value = true
        }
    }

    /**
     * Generates a new set of challenges for a given category, replacing the old ones.
     * @return 'True' if the operation was successful, 'False' otherwise.
     */
    fun refreshChallenges(category: EmojiCategory): Boolean {
        val lockedEmojisForCategory = allEmojisByCategory?.get(category)?.filter { !it.unlocked }

        val newChallenges = generateChallenges(
            category,
            min(lockedEmojisForCategory?.size ?: 0, MAX_CHALLENGES_PER_CATEGORY)
        )

        if (allChallengesByCategory == null || newChallenges == null) {
            return false
        }

        initMinimumLoadingTime()

        viewModelScope.launch {
            _categoriesLoadingFinished.value = false

            val oldChallenges = allChallengesByCategory!![category]!!

            challengesRepository.deleteChallenges(oldChallenges)
            challengesRepository.insertChallenges(newChallenges)

            // Making a query just to retrieve the items with the autogenerated id
            allChallengesByCategory!![category] = challengesRepository.getAllChallengerForCategory(category)

            _categoriesLoadingFinished.value = true
        }

        return true
    }

    fun getChallengesForCategory(category: EmojiCategory): List<Challenge>? = allChallengesByCategory?.get(category)

    fun getUnlockedCountForCategory(category: EmojiCategory): Int? = categoriesUnlockedCount?.get(category)

    fun getEmojiCountForCategory(category: EmojiCategory): Int? = categoriesEmojiCount?.get(category)

    fun getCategoryEmojis(category: EmojiCategory): List<Emoji>? = allEmojisByCategory?.get(category)

    private fun initMinimumLoadingTime() {
        _minLoadingTimeFinished.value = false

        object : CountDownTimer(MIN_LOADING_TIME_MS, MIN_LOADING_TIME_MS) {
            override fun onTick(millisUntilFinished: Long) {}

            override fun onFinish() {
                _minLoadingTimeFinished.value = true
            }
        }.start()
    }

    private fun generateChallenges(category: EmojiCategory, count: Int): List<Challenge>? {
        if (allEmojisByCategory == null) {
            return null
        }

        val lockedEmojisForCategory = allEmojisByCategory!![category]!!.filter { !it.unlocked }

        val rewardEmojis = generateSequence {
            lockedEmojisForCategory.random().unicode
        }.distinct()
        .take(count)
        .toList()

        val constraintChanceRange = 0..6

        return List(count) { index -> GeneralChallenge(
            totalGames = (1..MAX_GAMES_PER_CHALLENGE).random(),
            completedGames = 0,
            category = category,
            rewardEmojiUnicode = rewardEmojis[index],
            gameMode = GameMode.values().random(),
            boardSize = if (constraintChanceRange.random() == 0) BoardSize.values().random() else null,
            consecutiveGames = constraintChanceRange.random() == 0,
            hintsAllowed = constraintChanceRange.random() == 0,
            constrainedToCategory = Random.nextBoolean()
        )}
    }
}